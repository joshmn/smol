# frozen_string_literal: true

# smol - a small, zero-dependency CLI and REPL framework for Ruby
# https://github.com/joshmn/smol
#
# this file was auto-generated by bin/build-single-file on 2026-01-15
# drop it into your project and require it directly

require "logger"
require "readline"


# --- smol/version.rb ---

module Smol
  VERSION = "1.0.0"
end

# --- smol/colors.rb ---


module Smol
  module Colors
    refine String do
      def green
        "\e[32m#{self}\e[0m"
      end

      def red
        "\e[31m#{self}\e[0m"
      end

      def yellow
        "\e[33m#{self}\e[0m"
      end

      def bold
        "\e[1m#{self}\e[0m"
      end

      def dim
        "\e[2m#{self}\e[0m"
      end
    end
  end
end

# --- smol/coercion.rb ---


module Smol
  module Coercion
    TRUTHY_VALUES = %w[true 1 yes].freeze

    def coerce_value(raw, type)
      case type
      when :integer
        raw.to_i
      when :boolean
        TRUTHY_VALUES.include?(raw.to_s.downcase)
      else
        raw
      end
    end
  end
end

# --- smol/app_lookup.rb ---


module Smol
  module AppLookup
    private

    def app_class
      parts = self.class.name.split("::")
      parent = Object.const_get(parts.first)
      parent.const_get(:App)
    end
  end
end

# --- smol/check_result.rb ---


module Smol
  CheckResult = Struct.new(:passed, :message, keyword_init: true) do
    def passed?
      passed
    end

    def failed?
      !passed
    end

    def to_s
      status = passed? ? "passed" : "failed"
      "#{status}: #{message}"
    end
  end
end

# --- smol/output.rb ---


module Smol
  module Output
    using Colors
    extend self

    def out
      Smol.output
    end

    def banner(text)
      out.puts text.red
    end

    def header(text)
      out.puts text.bold
    end

    def desc(text)
      out.puts text.dim
    end

    def nl
      out.puts
    end

    def info(text)
      out.puts text
    end

    def success(text)
      out.puts text.green.bold
    end

    def failure(text)
      out.puts text.red.bold
    end

    def warning(text)
      out.puts text.yellow
    end

    def hint(text)
      out.puts text.dim
    end

    def label(text)
      out.puts text.yellow
    end

    def verbose(text)
      return unless Smol.verbose?

      out.puts text.dim
    end

    def debug(text)
      return unless Smol.debug?

      out.puts "[debug] #{text}".dim
    end

    def check_result(name, result)
      status = result.passed? ? "pass".green.bold : "fail".red.bold
      out.puts "#{status}: #{name}"
      out.puts "      #{result.message}"
    end

    def table(rows, headers: nil, indent: 0)
      return if rows.empty?

      all_rows = headers ? [headers] + rows : rows
      col_widths = table_column_widths(all_rows)
      prefix = " " * indent

      if headers
        header_line = table_format_row(headers, col_widths)
        out.puts "#{prefix}#{header_line}".bold
        out.puts "#{prefix}#{"-" * header_line.length}"
      end

      rows.each do |row|
        out.puts "#{prefix}#{table_format_row(row, col_widths)}"
      end
    end

    private

    def table_column_widths(rows)
      return [] if rows.empty?

      num_cols = rows.map(&:size).max
      (0...num_cols).map do |i|
        rows.map { |row| row[i].to_s.length }.max
      end
    end

    def table_format_row(row, widths)
      row.each_with_index.map do |cell, i|
        cell.to_s.ljust(widths[i] || 0)
      end.join("  ")
    end
  end
end

# --- smol/input.rb ---


module Smol
  module Input
    using Colors
    extend self

    def confirm(question, default: nil)
      hint = case default
             when true then "[Y/n]"
             when false then "[y/N]"
             else "[y/n]"
             end

      Smol.output.print "#{question} #{hint} ".yellow
      response = Smol.input.gets&.strip&.downcase

      case response
      when "", nil
        default
      when "y", "yes"
        true
      when "n", "no"
        false
      else
        default
      end
    end

    def ask(question, default: nil)
      prompt = default ? "#{question} [#{default}]" : question
      Smol.output.print "#{prompt}: ".yellow
      response = Smol.input.gets&.strip

      if response.nil? || response.empty?
        default
      else
        response
      end
    end

    def choose(question, choices, default: nil)
      Smol.output.puts question.yellow
      choices.each_with_index do |choice, i|
        marker = (i + 1) == default ? "*" : " "
        Smol.output.puts "#{marker} #{i + 1}) #{choice}"
      end

      Smol.output.print "choice: ".yellow
      response = Smol.input.gets&.strip

      if response.nil? || response.empty?
        default ? choices[default - 1] : nil
      else
        idx = response.to_i - 1
        idx >= 0 && idx < choices.size ? choices[idx] : nil
      end
    end
  end
end

# --- smol/config.rb ---


module Smol
  class Config
    include Coercion

    def initialize
      @settings = {}
      @values = {}
    end

    def setting(key, default:, type: :string, desc: nil)
      @settings[key] = { default: default, type: type, desc: desc }
    end

    def [](key)
      return @values[key] if @values.key?(key)

      setting = @settings[key]
      raise ArgumentError, "unknown config key: #{key}" unless setting

      env_key = key.to_s.upcase
      raw = ENV.fetch(env_key, setting[:default].to_s)

      @values[key] = coerce_value(raw, setting[:type])
    end

    def set(key, value)
      raise ArgumentError, "unknown config key: #{key}" unless @settings.key?(key)

      @values[key] = coerce_value(value.to_s, @settings[key][:type])
    end

    def settings
      @settings.dup
    end

    def to_h
      @settings.keys.each_with_object({}) { |k, h| h[k] = self[k] }
    end

    def each(&block)
      return enum_for(:each) unless block

      @settings.each_key { |k| yield k, self[k], @settings[k] }
    end
  end
end

# --- smol/config_display.rb ---


module Smol
  module ConfigDisplay
    include Output
    using Colors

    private

    def show_config
      out.puts "config:".bold
      @app.config.each do |key, value, setting|
        line = "  #{key}: #{value}"
        line += " - #{setting[:desc]}" if setting[:desc]
        out.puts line.dim
      end
    end

    def set_config(key, value)
      if key.nil? || value.nil?
        warning "usage: config:set <key> <value>"
        return
      end

      @app.config.set(key.to_sym, value)
      success "#{key} = #{@app.config[key.to_sym]}"
    rescue ArgumentError => e
      failure e.message
    end
  end
end

# --- smol/check.rb ---


module Smol
  class Check
    include AppLookup

    class << self
      def inherited(subclass)
        super
        register_to_app(subclass)
      end

      private

      def register_to_app(subclass)
        parts = subclass.name&.split("::")
        return unless parts && parts.size > 1

        parts[0..-2].size.times do |i|
          candidate_name = parts[0..-(i + 2)].join("::")
          begin
            candidate = Object.const_get(candidate_name)
          rescue NameError
            next
          end

          if candidate.respond_to?(:register_check)
            app_class = find_app_class_for(candidate)
            return if app_class&.explicit_registration?

            candidate.register_check(subclass)
            return
          end
        end
      end

      def find_app_class_for(candidate)
        return candidate if candidate.respond_to?(:explicit_registration?)

        if candidate.const_defined?(:App, false)
          app = candidate.const_get(:App)
          return app if app.respond_to?(:explicit_registration?)
        end
        nil
      end

      public

      def check_name
        name.split("::").last
          .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
          .gsub(/([a-z\d])([A-Z])/, '\1_\2')
          .downcase
          .tr("_", " ")
      end
    end

    def pass(message)
      CheckResult.new(passed: true, message: message)
    end

    def fail(message)
      CheckResult.new(passed: false, message: message)
    end

    def config
      app_class.config
    end
  end
end

# --- smol/command.rb ---


module Smol
  class Command
    include AppLookup

    class << self
      include Coercion

      def inherited(subclass)
        super
        subclass.prepend ErrorHandler
        subclass.prepend Callbacks
        subclass.prepend AutoMessage
        register_to_app(subclass)
      end

      private

      def register_to_app(subclass)
        parts = subclass.name&.split("::")
        return unless parts && parts.size > 1

        parts[0..-2].size.times do |i|
          candidate_name = parts[0..-(i + 2)].join("::")
          begin
            candidate = Object.const_get(candidate_name)
          rescue NameError
            next
          end

          if candidate.respond_to?(:register_command)
            app_class = find_app_class_for(candidate)
            return if app_class&.explicit_registration?

            candidate.register_command(subclass)
            return
          end
        end
      end

      def find_app_class_for(candidate)
        return candidate if candidate.respond_to?(:explicit_registration?)

        if candidate.const_defined?(:App, false)
          app = candidate.const_get(:App)
          return app if app.respond_to?(:explicit_registration?)
        end
        nil
      end

      public

      def command_name(text = nil)
        if text
          @command_name = text
        else
          @command_name || derive_command_name
        end
      end

      def title(text = nil)
        @title = text if text
        @title
      end

      def explain(text = nil)
        @explain = text if text
        @explain
      end

      def aliases(*args)
        @aliases = args if args.any?
        @aliases || []
      end

      def args(*args)
        @args = args if args.any?
        @args || []
      end

      def option(name, short: nil, type: :string, default: nil, desc: nil)
        @options ||= {}
        @options[name] = { short: short, type: type, default: default, desc: desc }
      end

      def options
        @options || {}
      end

      def desc(text = nil)
        @desc = text if text
        @desc || ""
      end

      def group(text = nil)
        @group = text if text
        @group
      end

      def before_action(method_name)
        @before_actions ||= []
        @before_actions << method_name
      end

      def before_actions
        @before_actions || []
      end

      def after_action(method_name)
        @after_actions ||= []
        @after_actions << method_name
      end

      def after_actions
        @after_actions || []
      end

      def matches?(input)
        input == command_name.to_s || aliases.map(&:to_s).include?(input)
      end

      def usage
        parts = [command_name]
        parts += args.map { |a| "<#{a}>" }
        options.each do |name, opt|
          flag = opt[:short] ? "-#{opt[:short]}/--#{name}" : "--#{name}"
          parts << "[#{flag}]"
        end
        parts.join(" ")
      end

      def parse_options(argv)
        positional = []
        opts = options.transform_values { |o| o[:default] }

        i = 0
        while i < argv.length
          arg = argv[i]
          if arg.start_with?("--")
            key, value = arg[2..].split("=", 2)
            key = key.tr("-", "_").to_sym
            if options[key]
              value ||= argv[i += 1]
              opts[key] = coerce_value(value, options[key][:type])
            end
          elsif arg.start_with?("-") && arg.length == 2
            short = arg[1]
            opt_name = options.find { |_, o| o[:short]&.to_s == short }&.first
            if opt_name
              value = argv[i += 1]
              opts[opt_name] = coerce_value(value, options[opt_name][:type])
            end
          else
            positional << arg
          end
          i += 1
        end

        [positional, opts]
      end

      def rescue_from(*exceptions, with: nil, &block)
        handler = block || with
        raise ArgumentError, "rescue_from requires a block or :with handler" unless handler

        @error_handlers ||= []
        exceptions.each do |exception|
          @error_handlers << [exception, handler]
        end
      end

      def error_handlers
        @error_handlers || []
      end

      private

      def derive_command_name
        return "anonymous" unless name

        name.split("::").last
          .gsub(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
          .gsub(/([a-z\d])([A-Z])/, '\1_\2')
          .downcase
      end
    end

    module AutoMessage
      def call(*args, **opts)
        if self.class.title
          header self.class.title
          desc self.class.explain if self.class.explain
          nl
        end
        super
      end
    end

    module Callbacks
      def call(*args, **opts)
        self.class.before_actions.each do |method_name|
          result = send(method_name, *args, **opts)
          return result if result == false
        end

        result = super

        self.class.after_actions.each do |method_name|
          send(method_name, *args, result: result, **opts)
        end

        result
      end
    end

    module ErrorHandler
      def call(*args, **opts)
        super
      rescue => e
        handler = find_error_handler(e)
        if handler
          if handler.is_a?(Symbol)
            send(handler, e)
          else
            instance_exec(e, &handler)
          end
        else
          raise
        end
      end

      private

      def find_error_handler(error)
        self.class.error_handlers.each do |exception_class, handler|
          return handler if error.is_a?(exception_class)
        end
        nil
      end
    end

    include Output
    include Input

    def config
      app_class.config
    end

    def app
      app_class
    end

    def checking(name)
      warning "checking: #{name}"
      nl
    end

    def dropping(target)
      warning "dropping: #{target}"
      nl
    end

    def done(hint_text = nil)
      nl
      success "done"
      hint hint_text if hint_text
    end

    def checks_passed?(all_passed, pass_hint: nil, fail_hint: nil)
      nl
      if all_passed
        success "all checks passed"
        hint pass_hint if pass_hint
      else
        failure "some checks failed"
        hint fail_hint if fail_hint
      end
      all_passed
    end

    def run_checks(*check_classes, args: [])
      results = check_classes.map do |klass|
        result = klass.new(*args).call
        check_result(klass.check_name, result)
        nl
        result.passed?
      end
      results.all?
    end
  end
end

# --- smol/app.rb ---


module Smol
  class App
    class << self
      def inherited(subclass)
        super
        subclass.instance_variable_set(:@commands, [])
        subclass.instance_variable_set(:@checks, [])
        subclass.instance_variable_set(:@mounts, {})

        parent_module = find_parent_module(subclass)
        setup_registry_methods(parent_module, subclass) if parent_module
      end

      def banner(text = nil)
        @banner = text if text
        @banner || ""
      end

      def cli(enabled = nil)
        @cli_enabled = enabled unless enabled.nil?
        @cli_enabled.nil? ? true : @cli_enabled
      end

      def repl(enabled = nil)
        @repl_enabled = enabled unless enabled.nil?
        @repl_enabled.nil? ? true : @repl_enabled
      end

      def boot(mode = nil)
        @boot_mode = mode if mode
        @boot_mode || :help
      end

      def history_file(path = nil)
        @history_file = path if path
        @history_file
      end

      def config
        @config ||= Config.new
      end

      def commands
        @commands ||= []
      end

      def checks
        @checks ||= []
      end

      def mounts
        @mounts ||= {}
      end

      def mount(app_class, as:)
        mounts[as.to_s] = app_class
      end

      def find_command(name)
        # Check for mounted app prefix (e.g., "admin:users")
        if name.include?(":")
          prefix, sub_name = name.split(":", 2)
          if mounts[prefix]
            return mounts[prefix].find_command(sub_name)
          end
        end

        commands.find { |c| c.matches?(name) }
      end

      def find_mount(name)
        mounts[name.to_s]
      end

      def register_command(command_class)
        commands << command_class
      end

      def register_check(check_class)
        checks << check_class
      end

      def register(command_class)
        @explicit_registration = true
        commands << command_class
      end

      def explicit_registration?
        @explicit_registration || false
      end

      private

      def find_parent_module(subclass)
        parts = subclass.name&.split("::")
        return nil unless parts && parts.size > 1

        parent_name = parts[0..-2].join("::")
        begin
          Object.const_get(parent_name)
        rescue NameError
          nil
        end
      end

      def setup_registry_methods(parent_module, app_class)
        unless parent_module.respond_to?(:register_command)
          parent_module.define_singleton_method(:register_command) do |cmd|
            app_class.register_command(cmd)
          end
        end
        unless parent_module.respond_to?(:register_check)
          parent_module.define_singleton_method(:register_check) do |check|
            app_class.register_check(check)
          end
        end
      end
    end
  end
end

# --- smol/repl.rb ---


module Smol
  class REPL
    include Output
    include ConfigDisplay
    using Colors

    def initialize(app, prompt:, history: true, history_file: nil, parent: nil)
      @app = app
      @prompt = prompt
      @history = history
      @history_file = history_file || File.expand_path("~/.smol_#{prompt}_history")
      @parent = parent
    end

    def run
      setup_readline if @history
      load_history if @history

      show_boot_message

      loop do
        input = read_input
        break if input.nil?

        input = input.strip
        next if input.empty?

        args = input.split(/\s+/)

        case args.first
        when "exit", "quit", "q"
          break
        when "back"
          break if @parent
          warning "not in a sub-app"
        when "help", "h", "?"
          help
        when "config", "c"
          show_config
        when "config:set"
          set_config(args[1], args[2])
        else
          # Check if entering a mounted sub-app
          mount = @app.find_mount(args.first)
          if mount && args.size == 1
            enter_subapp(mount, args.first)
          else
            dispatch(args)
          end
        end

        nl
      end

      save_history if @history
      hint "goodbye"
    end

    private

    def show_boot_message
      case @app.boot
      when :help
        show_boot_help
      when :minimal
        show_boot_minimal
      when :none
        # nothing
      else
        show_boot_help
      end
    end

    def show_boot_help
      banner @app.banner
      nl
      info @prompt.bold + " - interactive mode"
      nl
      help
      nl
      show_config
      nl
    end

    def show_boot_minimal
      banner @app.banner
      nl
      info @prompt.bold + " - interactive mode"
      hint "type 'help' for commands, 'exit' to quit"
      nl
      show_config
      nl
    end

    def enter_subapp(app_class, name)
      sub_repl = REPL.new(
        app_class,
        prompt: "#{@prompt}:#{name}",
        history: false,
        parent: self
      )
      sub_repl.run
    end

    def dispatch(args)
      cmd_name, *cmd_args = args
      klass = @app.find_command(cmd_name)

      if klass.nil?
        warning "unknown command: #{cmd_name}"
        hint "type 'help' for available commands"
        return
      end

      positional, opts = klass.parse_options(cmd_args)

      if klass.args.size > positional.size
        warning "usage: #{klass.usage}"
        return
      end

      klass.new.call(*positional, **opts)
    end

    def help
      out.puts "commands:".bold

      grouped = @app.commands.group_by(&:group)
      ungrouped = grouped.delete(nil) || []

      ungrouped.each do |cmd|
        print_command(cmd)
      end

      grouped.keys.sort.each do |group_name|
        nl
        out.puts "  #{group_name}:".bold
        grouped[group_name].each do |cmd|
          print_command(cmd, indent: 2)
        end
      end

      if @app.mounts.any?
        nl
        out.puts "  sub-apps:".bold
        @app.mounts.each do |name, app_class|
          out.puts "    #{name.ljust(28)}enter #{app_class.banner.empty? ? name : app_class.banner}"
        end
      end

      nl
      out.puts "  config, c".ljust(32) + "show current config"
      out.puts "  config:set <key> <value>".ljust(32) + "set a config value"
      out.puts "  help, h, ?".ljust(32) + "show this help"
      out.puts "  back".ljust(32) + "return to parent app" if @parent
      out.puts "  exit, quit, q".ljust(32) + "exit"
    end

    def print_command(cmd, indent: 0)
      prefix = "  " * (indent + 1)
      out.puts "#{prefix}#{cmd.usage.ljust(30 - indent * 2)}#{cmd.desc}"
      out.puts "#{prefix}  aliases: #{cmd.aliases.join(', ')}".dim if cmd.aliases.any?
    end

    def setup_readline
      Readline.completion_proc = proc do |input|
        commands = @app.commands.flat_map { |c| [c.command_name.to_s] + c.aliases.map(&:to_s) }
        builtins = %w[help h ? config c config:set exit quit q]
        (commands + builtins).grep(/^#{Regexp.escape(input)}/)
      end
    end

    def load_history
      return unless File.exist?(@history_file)

      File.readlines(@history_file).each do |line|
        Readline::HISTORY << line.chomp
      end
    rescue StandardError
      # ignore history load errors
    end

    def save_history
      File.open(@history_file, "w") do |f|
        Readline::HISTORY.to_a.last(1000).each do |line|
          f.puts line
        end
      end
    rescue StandardError
      # ignore history save errors
    end

    def read_input
      if @history
        prompt_str = "#{@prompt}> "
        line = Readline.readline(prompt_str, true)
        Readline::HISTORY.pop if line&.strip&.empty?
        line
      else
        Smol.output.print "#{@prompt}> ".yellow
        Smol.input.gets
      end
    end
  end
end

# --- smol/cli.rb ---


module Smol
  class CLI
    include Output
    include ConfigDisplay
    using Colors

    def initialize(app, prompt:, history: true)
      @app = app
      @prompt = prompt
      @history = history
    end

    def run(args)
      if args.empty?
        if @app.repl
          REPL.new(@app, prompt: @prompt, history: @history, history_file: history_file_path).run
        else
          usage
          exit 1
        end
        return
      end

      unless @app.cli
        failure "CLI mode is disabled"
        hint "run without arguments for interactive mode" if @app.repl
        exit 1
      end

      cmd_name, *cmd_args = args

      case cmd_name
      when "help", "-h", "--help"
        usage
        exit 1
      when "config"
        show_config
        return
      when "config:set"
        set_config(cmd_args[0], cmd_args[1])
        return
      end

      klass = @app.find_command(cmd_name)

      if klass.nil?
        usage
        exit 1
      end

      positional, opts = klass.parse_options(cmd_args)
      result = klass.new.call(*positional, **opts)

      if result == true || result == false
        exit(result ? 0 : 1)
      end
    end

    private

    def usage
      banner @app.banner

      out.puts <<~USAGE
        #{@prompt.bold} - CLI app

        #{"usage:".bold}
          ./#{@prompt}.rb              start interactive mode
          ./#{@prompt}.rb <command>    run a single command

        #{"commands:".bold}
      USAGE

      grouped = @app.commands.group_by(&:group)
      ungrouped = grouped.delete(nil) || []

      ungrouped.each do |cmd|
        out.puts "  #{cmd.usage.ljust(34)}#{cmd.desc}"
      end

      grouped.keys.sort.each do |group_name|
        nl
        out.puts "  #{group_name}:".bold
        grouped[group_name].each do |cmd|
          out.puts "    #{cmd.usage.ljust(32)}#{cmd.desc}"
        end
      end

      if @app.mounts.any?
        nl
        out.puts "  #{"sub-apps:".bold}"
        @app.mounts.each do |name, app_class|
          out.puts "    #{(name + ":*").ljust(32)}#{app_class.banner.empty? ? name : app_class.banner}"
        end
      end

      out.puts "  #{"config".ljust(34)}show current config"
      out.puts "  #{"config:set <key> <value>".ljust(34)}set a config value"

      nl
      show_config
      nl

      out.puts "#{"environment:".bold}"

      @app.config.each do |key, _, setting|
        line = "  #{key.to_s.upcase}"
        line += " - #{setting[:desc]}" if setting[:desc]
        out.puts line
      end
    end

    def history_file_path
      @app.history_file || File.expand_path("~/.smol_#{@prompt}_history")
    end
  end
end

# --- smol.rb (main module) ---




module Smol
  class Error < StandardError; end

  class << self
    attr_writer :output, :input, :logger, :verbose, :quiet

    def output
      @output ||= $stdout
    end

    def input
      @input ||= $stdin
    end

    def logger
      @logger ||= Logger.new($stderr, level: Logger::WARN)
    end

    def verbose?
      @verbose || ENV["VERBOSE"] == "1" || ENV["VERBOSE"] == "true"
    end

    def quiet?
      @quiet || ENV["QUIET"] == "1" || ENV["QUIET"] == "true"
    end

    def debug?
      @debug || ENV["DEBUG"] == "1" || ENV["DEBUG"] == "true"
    end

    def debug=(value)
      @debug = value
    end
  end
end
